Thank you for sharing the existing code! Letâ€™s enhance it to read the Bridge Control for each of the upstream and downstream BDFs. Weâ€™ll create a new list called bridge_controls to store the results.

Hereâ€™s the modified code:

Python

import subprocess

def read_header(bus):
    try:
        bridge_control_output = subprocess.check_output(["setpci", "-s", bus, "0e.w"])
        return bridge_control_output.decode().strip()
    except subprocess.CalledProcessError:
        return None

def read_secondary_bus_number(bus):
    try:
        secondary_bus_output = subprocess.check_output(["setpci", "-s", bus, "19.b"])
        return secondary_bus_output.decode().strip()
    except subprocess.CalledProcessError:
        return None

def read_bridge_control(bus):
    try:
        bridge_control_output = subprocess.check_output(["setpci", "-s", bus, "3e.w"])
        return bridge_control_output.decode().strip()
    except subprocess.CalledProcessError:
        return None

try:
    # Run the 'lspci | cut -d ' ' -f 1' command in the terminal
    output = subprocess.check_output("lspci | cut -d ' ' -f 1", shell=True, stderr=subprocess.STDOUT)
    # Decode bytes object to string
    output = output.decode('utf-8')
    # Split the string into lines
    lines = output.strip().split('\n')
    # Initialize an empty list
    pci_list = []
    # Iterate over each line and append it to the list
    for line in lines:
        pci_list.append(line.strip())
    
    # Create a new list called listbdf with elements having header number's last bit as 1
    listbdf = []
    for item in pci_list:
        header = read_header(item)
        if header and int(header, 16) & 1:
            listbdf.append(item)
    
    # Create a new list called downstream_bdfs with secondary bus numbers
    downstream_bdfs = []
    for bdf in listbdf:
        secondary_bus = read_secondary_bus_number(bdf)
        if secondary_bus:
            downstream_bdfs.append(f"{secondary_bus}:00.0")
    
    # Read the Bridge Control for each upstream and downstream BDF
    bridge_controls = {}
    for bdf in downstream_bdfs:
        bridge_control = read_bridge_control(bdf)
        if bridge_control:
            bridge_controls[bdf] = bridge_control
    
    # Print the Bridge Control values
    for bdf, control in bridge_controls.items():
        print(f"Bridge Control for {bdf}: {control}")
except subprocess.CalledProcessError as e:
    print(f"Error executing the command: {e.output}")
AI-generated code. Review and use carefully. More info on FAQ.
This modified code will populate bridge_controls with the Bridge Control values for each upstream and downstream BDF. Feel free to test it, and let me know if you have any further questions or need additional assistance! ðŸ˜Š
